<!-- Generated by DocGen-LM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>database</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <button id="sidebar-toggle">Menu</button>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul><li><a href="index.html"><strong>üè† Project Overview</strong></a></li><li><details><summary>app</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="__main__.html">__main__</a></li><li><a href="config.html">config</a></li><li><a href="logging.html">logging</a></li><li><details><summary>ingest</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="preview.html">preview</a></li><li><a href="service.html">service</a></li><li><details><summary>parsers</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="docx_parser.html">docx_parser</a></li><li><a href="markdown_parser.html">markdown_parser</a></li><li><a href="pdf_parser.html">pdf_parser</a></li><li><a href="text_parser.html">text_parser</a></li></ul></details></li></ul></details></li><li><details><summary>retrieval</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="index.html">index</a></li><li><a href="search.html">search</a></li></ul></details></li><li><details><summary>services</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="backup_service.html">backup_service</a></li><li><a href="conversation_manager.html">conversation_manager</a></li><li><a href="conversation_settings.html">conversation_settings</a></li><li><a href="document_hierarchy.html">document_hierarchy</a></li><li><a href="export_service.html">export_service</a></li><li><a href="lmstudio_client.html">lmstudio_client</a></li><li><a href="progress_service.html">progress_service</a></li><li><a href="project_service.html">project_service</a></li><li><a href="settings_service.html">settings_service</a></li></ul></details></li><li><details><summary>storage</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="database.html">database</a></li></ul></details></li><li><details><summary>ui</summary><ul><li><a href="__init__.html">__init__</a></li><li><a href="answer_view.html">answer_view</a></li><li><a href="evidence_panel.html">evidence_panel</a></li><li><a href="main_window.html">main_window</a></li><li><a href="question_input_widget.html">question_input_widget</a></li></ul></details></li></ul></details></li><li><details><summary>tests</summary><ul><li><a href="test_dynamic_planning.html">test_dynamic_planning</a></li><li><a href="test_export_and_backup.html">test_export_and_backup</a></li><li><a href="test_ingest_service.html">test_ingest_service</a></li><li><a href="test_lmstudio_integration.html">test_lmstudio_integration</a></li><li><a href="test_parser_file_types.html">test_parser_file_types</a></li><li><a href="test_preview_service.html">test_preview_service</a></li><li><a href="test_project_service.html">test_project_service</a></li><li><a href="test_retrieval_index.html">test_retrieval_index</a></li><li><a href="test_search_service.html">test_search_service</a></li><li><a href="test_storage.html">test_storage</a></li><li><a href="test_ui_main_window.html">test_ui_main_window</a></li></ul></details></li></ul>
    </div>
    <div class="content">
        <h1>database</h1>
        <p>This module defines a comprehensive set of database utilities and repository classes for managing structured data within SQLite storage. It includes a `DatabaseManager` class that handles database connections, schema initialization, migrations, transactions, and import/export operations, along with a custom `DatabaseError` exception for handling failures. The module implements several repository classes: `BaseRepository` providing shared functionality, `ProjectRepository` for CRUD operations on project data, `DocumentRepository` for managing documents, their file versions, tags, and embeddings including folder-based organization and tag counting, `IngestDocumentRepository` for handling parsed document data with text, previews, and search indexes including versioning and chunking support, `ChatRepository` for chat session management with query scopes, citations, and reasoning summaries, and `BackgroundTaskLogRepository` for tracking background task execution metadata with filtering and retrieval capabilities. Each repository class uses SQL queries for database interactions and includes helper methods for path normalization, pattern building, and data decoding from database results.</p>
<h2 id="DatabaseError">Class: DatabaseError</h2>
<p>This code defines a custom exception class named `DatabaseError` that inherits from Python&#x27;s built-in `RuntimeError`. The exception is specifically intended to be raised when database initialization or migration processes encounter failures. The class serves as a specialized error type to handle database-related runtime issues in a structured manner.</p>
<h2 id="DatabaseManager">Class: DatabaseManager</h2>
<p>The `DatabaseManager` class handles SQLite database connections with thread-safe singleton access, manages schema initialization and migrations, and provides methods for exporting and importing database snapshots. It ensures atomic operations through transaction handling and maintains a consistent database version using PRAGMA user_version. The class supports concurrent access by thread ID and includes functionality for backup and restoration of the database state.</p>
<h3 id="__init__">Method: __init__(self, path: str | Path) -&gt; None</h3>
<p>Initializes a `DatabaseManager` instance with a specified file path, ensuring the parent directory exists. It sets up a reentrant lock for thread-safe database connection handling and initializes a dictionary to store database connections per thread.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000">self</span><span style="color: #666666">.</span>path <span style="color: #666666">=</span> Path(path)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>path<span style="color: #666666">.</span>parent<span style="color: #666666">.</span>exists():
            <span style="color: #008000">self</span><span style="color: #666666">.</span>path<span style="color: #666666">.</span>parent<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>_connection_lock <span style="color: #666666">=</span> threading<span style="color: #666666">.</span>RLock()
        <span style="color: #008000">self</span><span style="color: #666666">.</span>_connections: <span style="color: #008000">dict</span>[<span style="color: #008000">int</span>, sqlite3<span style="color: #666666">.</span>Connection] <span style="color: #666666">=</span> {}
</code></pre>
<h3 id="connect">Method: connect(self) -&gt; sqlite3.Connection</h3>
<p>The function `connect` returns a singleton SQLite database connection tailored for the thread it is called from. It ensures that each thread has its own connection instance, avoiding concurrency issues. The connection is configured with `check_same_thread=False` to allow use across threads, sets a `sqlite3.Row` factory for row access by column name, and enables foreign key constraints. A lock is used to manage access to the connections dictionary, ensuring thread-safe creation and retrieval of connections.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">connect</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> sqlite3<span style="color: #666666">.</span>Connection:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return a singleton SQLite connection with sensible defaults.&quot;&quot;&quot;</span>
        thread_id <span style="color: #666666">=</span> threading<span style="color: #666666">.</span>get_ident()
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_connection_lock:
            connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_connections<span style="color: #666666">.</span>get(thread_id)
            <span style="color: #008000; font-weight: bold">if</span> connection <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
                connection <span style="color: #666666">=</span> sqlite3<span style="color: #666666">.</span>connect(<span style="color: #008000">self</span><span style="color: #666666">.</span>path, check_same_thread<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
                connection<span style="color: #666666">.</span>row_factory <span style="color: #666666">=</span> sqlite3<span style="color: #666666">.</span>Row
                connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;PRAGMA foreign_keys = ON&quot;</span>)
                <span style="color: #008000">self</span><span style="color: #666666">.</span>_connections[thread_id] <span style="color: #666666">=</span> connection
            <span style="color: #008000; font-weight: bold">return</span> connection
</code></pre>
<h3 id="close">Method: close(self) -&gt; None</h3>
<p>The `close` method closes all active database connections managed by the `DatabaseManager` instance. It acquires a lock to ensure thread safety, retrieves all current connections, clears the internal connections dictionary, and then closes each connection individually. This ensures that all database resources are properly released when the manager is closed.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">close</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Close the underlying database connection if it exists.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_connection_lock:
            connections <span style="color: #666666">=</span> <span style="color: #008000">list</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>_connections<span style="color: #666666">.</span>values())
            <span style="color: #008000">self</span><span style="color: #666666">.</span>_connections<span style="color: #666666">.</span>clear()
        <span style="color: #008000; font-weight: bold">for</span> connection <span style="color: #AA22FF; font-weight: bold">in</span> connections:
            connection<span style="color: #666666">.</span>close()
</code></pre>
<h3 id="initialize">Method: initialize(self) -&gt; None</h3>
<p>The `initialize` method bootstraps the database schema by ensuring it is up-to-date with the application&#x27;s required schema version. It retrieves the current schema version, validates it against the expected version, and applies necessary migrations if the schema is outdated. If the schema is new, it installs the base schema. The operation is wrapped in a transaction to ensure atomicity. If the database version exceeds the supported version, it raises a `DatabaseError`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">initialize</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Bootstrap the database schema, applying migrations if required.&quot;&quot;&quot;</span>
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>connect()
        <span style="color: #008000; font-weight: bold">try</span>:
            <span style="color: #008000; font-weight: bold">with</span> connection:  <span style="color: #3D7B7B; font-style: italic"># Start a transaction so initialization is atomic.</span>
                version <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_get_user_version(connection)
                <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">&gt;</span> SCHEMA_VERSION:
                    <span style="color: #008000; font-weight: bold">raise</span> DatabaseError(
                        <span style="color: #BA2121">&quot;Database schema version is newer than this application supports&quot;</span>
                    )
                <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
                    <span style="color: #008000">self</span><span style="color: #666666">.</span>_install_base_schema(connection)
                <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">&lt;</span> SCHEMA_VERSION:
                    <span style="color: #008000">self</span><span style="color: #666666">.</span>_apply_migrations(connection, version)
        <span style="color: #008000; font-weight: bold">except</span> sqlite3<span style="color: #666666">.</span>DatabaseError <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
            <span style="color: #008000; font-weight: bold">raise</span> DatabaseError(<span style="color: #008000">str</span>(exc)) <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">exc</span>
</code></pre>
<h3 id="_install_base_schema">Method: _install_base_schema(self, connection: sqlite3.Connection) -&gt; None</h3>
<p>The function `_install_base_schema` initializes the database schema by reading SQL statements from a file specified by `SCHEMA_FILENAME` and executing them against the provided SQLite connection. After executing the schema script, it sets the database&#x27;s user version to the value defined by `SCHEMA_VERSION`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_install_base_schema</span>(<span style="color: #008000">self</span>, connection: sqlite3<span style="color: #666666">.</span>Connection) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        schema_path <span style="color: #666666">=</span> Path(<span style="color: #19177C">__file__</span>)<span style="color: #666666">.</span>with_name(SCHEMA_FILENAME)
        schema_sql <span style="color: #666666">=</span> schema_path<span style="color: #666666">.</span>read_text(encoding<span style="color: #666666">=</span><span style="color: #BA2121">&quot;utf-8&quot;</span>)
        connection<span style="color: #666666">.</span>executescript(schema_sql)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>_set_user_version(connection, SCHEMA_VERSION)
</code></pre>
<h3 id="_apply_migrations">Method: _apply_migrations(self, connection: sqlite3.Connection, current: int) -&gt; None</h3>
<p>The function `_apply_migrations` is a placeholder method intended for applying database schema migrations. It checks if the current schema version is less than the target `SCHEMA_VERSION`. If so, it re-applies the base schema using the `_install_base_schema` method to ensure consistency, without implementing incremental migration logic.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_apply_migrations</span>(<span style="color: #008000">self</span>, connection: sqlite3<span style="color: #666666">.</span>Connection, current: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Placeholder for future migrations from ``current`` to ``SCHEMA_VERSION``.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> current <span style="color: #666666">&gt;=</span> SCHEMA_VERSION:
            <span style="color: #008000; font-weight: bold">return</span>
        <span style="color: #3D7B7B; font-style: italic"># No incremental migrations yet; reapply schema to fill gaps.</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>_install_base_schema(connection)
</code></pre>
<h3 id="_get_user_version">Method: _get_user_version(connection: sqlite3.Connection) -&gt; int</h3>
<p>Retrieves the `user_version` pragma value from a SQLite database connection, returning it as an integer. If no value is found, returns 0.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_get_user_version</span>(connection: sqlite3<span style="color: #666666">.</span>Connection) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
        cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;PRAGMA user_version&quot;</span>)
        row <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">int</span>(row[<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">0</span>
</code></pre>
<h3 id="_set_user_version">Method: _set_user_version(connection: sqlite3.Connection, version: int) -&gt; None</h3>
<p>Sets the user version pragma of the provided SQLite database connection to the specified version integer.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_set_user_version</span>(connection: sqlite3<span style="color: #666666">.</span>Connection, version: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">f&quot;PRAGMA user_version = </span><span style="color: #A45A77; font-weight: bold">{</span>version<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">&quot;</span>)
</code></pre>
<h3 id="transaction">Method: transaction(self) -&gt; Iterable[sqlite3.Connection]</h3>
<p>The function `transaction` is a context manager that facilitates database operations within a transactional scope. It establishes a database connection, yields the connection for use in a `with` block, and ensures that the transaction is committed if no exceptions occur. If a `sqlite3.DatabaseError` is raised during the operation, it is caught and re-raised as a `DatabaseError`. The function uses `Iterable[sqlite3.Connection]` to indicate that it yields a database connection object.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">transaction</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> Iterable[sqlite3<span style="color: #666666">.</span>Connection]:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Context manager that wraps operations in a transaction.&quot;&quot;&quot;</span>
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>connect()
        <span style="color: #008000; font-weight: bold">try</span>:
            <span style="color: #008000; font-weight: bold">with</span> connection:
                <span style="color: #008000; font-weight: bold">yield</span> connection
        <span style="color: #008000; font-weight: bold">except</span> sqlite3<span style="color: #666666">.</span>DatabaseError <span style="color: #008000; font-weight: bold">as</span> exc:  <span style="color: #3D7B7B; font-style: italic"># pragma: no cover - defensive</span>
            <span style="color: #008000; font-weight: bold">raise</span> DatabaseError(<span style="color: #008000">str</span>(exc)) <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">exc</span>
</code></pre>
<h3 id="export_database">Method: export_database(self, destination: str | Path) -&gt; Path</h3>
<p>The `export_database` function creates a consistent snapshot of the database at the specified destination. If the destination is a directory, it generates a filename with a timestamp prefix. It ensures the destination directory exists, establishes a connection to the current database, and performs a backup to the specified path using SQLite&#x27;s backup functionality. The function returns the path to the created backup file.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">export_database</span>(<span style="color: #008000">self</span>, destination: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path) <span style="color: #666666">-&gt;</span> Path:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Create a consistent snapshot of the database at ``destination``.&quot;&quot;&quot;</span>
        destination_path <span style="color: #666666">=</span> Path(destination)
        <span style="color: #008000; font-weight: bold">if</span> destination_path<span style="color: #666666">.</span>is_dir():
            timestamp <span style="color: #666666">=</span> _dt<span style="color: #666666">.</span>datetime<span style="color: #666666">.</span>utcnow()<span style="color: #666666">.</span>strftime(<span style="color: #BA2121">&quot;%Y%m</span><span style="color: #A45A77; font-weight: bold">%d</span><span style="color: #BA2121">%H%M%S&quot;</span>)
            destination_path <span style="color: #666666">=</span> destination_path <span style="color: #666666">/</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>path<span style="color: #666666">.</span>stem<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">-backup-</span><span style="color: #A45A77; font-weight: bold">{</span>timestamp<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">.db&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> destination_path<span style="color: #666666">.</span>parent<span style="color: #666666">.</span>exists():
            destination_path<span style="color: #666666">.</span>parent<span style="color: #666666">.</span>mkdir(parents<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>, exist_ok<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>connect()
        <span style="color: #008000; font-weight: bold">with</span> sqlite3<span style="color: #666666">.</span>connect(destination_path) <span style="color: #008000; font-weight: bold">as</span> backup_conn:
            connection<span style="color: #666666">.</span>backup(backup_conn)
        <span style="color: #008000; font-weight: bold">return</span> destination_path
</code></pre>
<h3 id="import_database">Method: import_database(self, source: str | Path) -&gt; Path</h3>
<p>The `import_database` function replaces the current database file with a specified source database file, ensuring schema compatibility. It validates the existence of the source file, closes the current database connection, copies the source database to a staging location, checks the schema version of the staging database against the supported version, raises an error if the schema is too new, and finally replaces the current database file with the staging file after reinitializing the database manager. The function returns the path of the newly imported database.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">import_database</span>(<span style="color: #008000">self</span>, source: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path) <span style="color: #666666">-&gt;</span> Path:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Replace the current database with ``source`` ensuring schema compatibility.&quot;&quot;&quot;</span>
        source_path <span style="color: #666666">=</span> Path(source)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> source_path<span style="color: #666666">.</span>exists():
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #CB3F38; font-weight: bold">FileNotFoundError</span>(source_path)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>close()
        staging_path <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>path<span style="color: #666666">.</span>with_suffix(<span style="color: #BA2121">&quot;.staging&quot;</span>)
        shutil<span style="color: #666666">.</span>copy2(source_path, staging_path)
        <span style="color: #008000; font-weight: bold">with</span> sqlite3<span style="color: #666666">.</span>connect(staging_path) <span style="color: #008000; font-weight: bold">as</span> staging_conn:
            version <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_get_user_version(staging_conn)
            <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">&gt;</span> SCHEMA_VERSION:
                <span style="color: #008000; font-weight: bold">raise</span> DatabaseError(
                    <span style="color: #BA2121">&quot;Imported database has a newer schema version than supported&quot;</span>
                )
        staging_path<span style="color: #666666">.</span>replace(<span style="color: #008000">self</span><span style="color: #666666">.</span>path)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>initialize()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>path
</code></pre>
<h2 id="BaseRepository">Class: BaseRepository</h2>
<p>The `BaseRepository` class provides shared functionality for repository implementations, including database connection management and utility methods for handling database rows. It defines a context manager `transaction` that yields a database connection within a transaction scope. The `_row_to_dict` static method converts a SQLite row object into a dictionary representation.</p>
<h3 id="__init__">Method: __init__(self, db: DatabaseManager) -&gt; None</h3>
<p>Initializes the `BaseRepository` instance with a `DatabaseManager` object, which is stored as an attribute for database operations.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, db: DatabaseManager) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000">self</span><span style="color: #666666">.</span>db <span style="color: #666666">=</span> db
</code></pre>
<h3 id="transaction">Method: transaction(self) -&gt; Iterable[sqlite3.Connection]</h3>
<p>The function `transaction` provides a context manager for database transactions within the `BaseRepository` class. It yields a SQLite database connection obtained from `self.db.transaction()`, enabling operations to be executed within a transactional scope. The function is iterable, allowing it to be used in a `with` statement to ensure proper handling of database connections and transactions.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">transaction</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> Iterable[sqlite3<span style="color: #666666">.</span>Connection]:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            <span style="color: #008000; font-weight: bold">yield</span> connection
</code></pre>
<h3 id="_row_to_dict">Method: _row_to_dict(row: sqlite3.Row | None) -&gt; dict[str, Any] | None</h3>
<p>Converts a SQLite database row into a dictionary representation.

This function takes a row from a SQLite query result and transforms it into a dictionary where the keys are the column names and the values are the corresponding row values. If the input row is None, it returns None. The function uses the row&#x27;s `keys()` method to retrieve column names and accesses each column by name to build the dictionary.

Parameters:

Returns:</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_row_to_dict</span>(row: sqlite3<span style="color: #666666">.</span>Row <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">return</span> {key: row[key] <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> row<span style="color: #666666">.</span>keys()}
</code></pre>
<h2 id="ProjectRepository">Class: ProjectRepository</h2>
<p>The `ProjectRepository` class provides methods to perform create, read, update, and delete operations on project records in a database. The `create` method inserts a new project and returns the created record. The `get`, `list`, `update`, and `delete` methods retrieve, list, modify, and remove projects respectively, using SQL queries executed within database transactions.</p>
<h3 id="create">Method: create(self, name: str, description: str | None=None) -&gt; dict[str, Any]</h3>
<p>Creates a new project entry in the database with the specified name and optional description. Returns the created project&#x27;s data as a dictionary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create</span>(<span style="color: #008000">self</span>, name: <span style="color: #008000">str</span>, description: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;INSERT INTO projects (name, description) VALUES (?, ?)&quot;</span>,
                (name, description),
            )
            project_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(project_id)
</code></pre>
<h3 id="get">Method: get(self, project_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a project record from the database by its ID and returns it as a dictionary, or None if not found. Uses a SQL query to select all columns from the `projects` table where the `id` matches the provided `project_id`. The resulting row is converted to a dictionary using the `_row_to_dict` method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()
        row <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM projects WHERE id = ?&quot;</span>, (project_id,)
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
</code></pre>
<h3 id="list">Method: list(self) -&gt; list[dict[str, Any]]</h3>
<p>The function `list` retrieves all project records from the database, ordered by their creation date in ascending order. It executes a SQL query to select all columns from the `projects` table, converts each resulting row into a dictionary using a helper method `_row_to_dict`, and returns a list of these dictionaries. The function filters out any null rows before processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()
        rows <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM projects ORDER BY created_at ASC&quot;</span>
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="update">Method: update(self, project_id: int, **fields: Any) -&gt; dict[str, Any] | None</h3>
<p>The `update` method in the `ProjectRepository` class updates specific fields of a project record in the database based on the provided `project_id`. It constructs an SQL `UPDATE` statement using the given fields and their values, and executes the update within a transactional context. If no fields are provided, it retrieves and returns the current project data. The method returns the updated project data as a dictionary or `None` if no fields are specified.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">update</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>, <span style="color: #666666">**</span>fields: Any) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> fields:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(project_id)
        columns <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;, &quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> = ?&quot;</span> <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> fields<span style="color: #666666">.</span>keys())
        values <span style="color: #666666">=</span> <span style="color: #008000">list</span>(fields<span style="color: #666666">.</span>values()) <span style="color: #666666">+</span> [project_id]
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">f&quot;UPDATE projects SET </span><span style="color: #A45A77; font-weight: bold">{</span>columns<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> WHERE id = ?&quot;</span>, values)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(project_id)
</code></pre>
<h3 id="delete">Method: delete(self, project_id: int) -&gt; None</h3>
<p>The `delete` function removes a project from the repository based on its unique identifier. It executes a SQL DELETE statement on the `projects` table, targeting the specific project by its `id`. The operation is performed within a transactional context to ensure data consistency.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">delete</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;DELETE FROM projects WHERE id = ?&quot;</span>, (project_id,))
</code></pre>
<h2 id="DocumentRepository">Class: DocumentRepository</h2>
<p>The `DocumentRepository` class provides methods to manage documents, including creating, retrieving, updating, and deleting documents with associated metadata, file paths, and folder structures. It supports tagging documents and listing them based on project, folder, or tag criteria, with functionality for recursive folder searches and tag count updates. The class also handles file versioning for documents, allowing storage and retrieval of multiple versions with checksums and file sizes.</p>
<h3 id="create">Method: create(self, project_id: int, title: str, *, source_type: str | None=None, source_path: str | Path | None=None, metadata: dict[str, Any] | None=None, folder_path: str | Path | None=None) -&gt; dict[str, Any]</h3>
<p>The `create` method inserts a new document record into the `documents` table of the database. It accepts parameters for the project ID, title, source type, source path, folder path, and metadata. The source path and folder path are normalized using helper methods `_normalize_path` and `_normalize_folder`. If no folder path is provided but a source path is given, the parent directory of the source path is used as the folder path. Metadata is serialized to JSON before being stored. The method returns the created document&#x27;s data by calling `self.get(document_id)` after inserting the record. The operation is performed within a database transaction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create</span>(
        <span style="color: #008000">self</span>,
        project_id: <span style="color: #008000">int</span>,
        title: <span style="color: #008000">str</span>,
        <span style="color: #666666">*</span>,
        source_type: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        source_path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        metadata: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        folder_path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        metadata_json <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(metadata) <span style="color: #008000; font-weight: bold">if</span> metadata <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
        stored_path <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_path(source_path)
        folder <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_folder(folder_path)
        <span style="color: #008000; font-weight: bold">if</span> folder <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #AA22FF; font-weight: bold">and</span> stored_path <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            folder <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_folder(Path(stored_path)<span style="color: #666666">.</span>parent)
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO documents (</span>
<span style="color: #BA2121; font-style: italic">                    project_id, title, source_type, source_path, folder_path, metadata</span>
<span style="color: #BA2121; font-style: italic">                )</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (project_id, title, source_type, stored_path, folder, metadata_json),
            )
            document_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(document_id)
</code></pre>
<h3 id="get">Method: get(self, document_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a document from the database by its ID and returns it as a dictionary, or None if not found. The document data is decoded from a database row using the `_decode_document_row` method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM documents WHERE id = ?&quot;</span>, (document_id,)
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row)
</code></pre>
<h3 id="list_for_project">Method: list_for_project(self, project_id: int) -&gt; list[dict[str, Any]]</h3>
<p>Returns a list of decoded document records associated with a given project ID, ordered by creation date in ascending order. Each record is retrieved from the database using a SQL query that filters documents based on the specified project ID. The method applies a decoding function to each database row and includes only non-null results in the final output list.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_for_project</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM documents WHERE project_id = ? ORDER BY created_at ASC&quot;</span>,
            (project_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [record <span style="color: #008000; font-weight: bold">for</span> record <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows) <span style="color: #008000; font-weight: bold">if</span> record]
</code></pre>
<h3 id="list_for_folder">Method: list_for_folder(self, project_id: int, folder_path: str | Path, *, recursive: bool=True) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_for_folder` retrieves a list of documents or items within a specified folder path for a given project. It accepts a project ID, a folder path (either as a string or Path object), and an optional recursive flag to determine whether to include items in subfolders. The function delegates the actual listing operation to `self.list_for_scope`, passing the project ID, folder path, and recursive setting as arguments. It returns a list of dictionaries containing document or item details.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_for_folder</span>(
        <span style="color: #008000">self</span>,
        project_id: <span style="color: #008000">int</span>,
        folder_path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path,
        <span style="color: #666666">*</span>,
        recursive: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>list_for_scope(project_id, folder<span style="color: #666666">=</span>folder_path, recursive<span style="color: #666666">=</span>recursive)
</code></pre>
<h3 id="list_for_tag">Method: list_for_tag(self, project_id: int, tag_id: int) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_for_tag` retrieves a list of items associated with a specific tag within a given project. It takes a `project_id` and a `tag_id` as parameters and returns a list of dictionaries containing item details. The implementation delegates the actual retrieval logic to the `list_for_scope` method, passing the `project_id` and a list containing the `tag_id` as the scope filter.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_for_tag</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>, tag_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>list_for_scope(project_id, tags<span style="color: #666666">=</span>[tag_id])
</code></pre>
<h3 id="list_for_scope">Method: list_for_scope(self, project_id: int, *, tags: Iterable[int] | None=None, folder: str | Path | None=None, recursive: bool=True) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_for_scope` retrieves a list of documents from the database based on specified filtering criteria. It accepts parameters to scope the results by project ID, optional tags, folder path, and recursion settings. The function constructs a dynamic SQL query that joins the `documents` table with `tag_links` if tag-based filtering is applied, and includes conditions for folder paths, either exact matches or recursive patterns. It supports grouping and having clauses to ensure all specified tags are matched when filtering by tags. The resulting rows are decoded into document records and returned as a list of dictionaries.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_for_scope</span>(
        <span style="color: #008000">self</span>,
        project_id: <span style="color: #008000">int</span>,
        <span style="color: #666666">*</span>,
        tags: Iterable[<span style="color: #008000">int</span>] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        folder: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        recursive: <span style="color: #008000">bool</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">True</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        tag_ids <span style="color: #666666">=</span> <span style="color: #008000">list</span>(<span style="color: #008000">dict</span><span style="color: #666666">.</span>fromkeys(tags <span style="color: #AA22FF; font-weight: bold">or</span> []))
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()
        params: <span style="color: #008000">list</span>[Any] <span style="color: #666666">=</span> [project_id]
        where_clauses <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;documents.project_id = ?&quot;</span>]
        joins: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
        group_by <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>
        having <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;</span>

        <span style="color: #008000; font-weight: bold">if</span> tag_ids:
            joins<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;INNER JOIN tag_links ON tag_links.document_id = documents.id&quot;</span>)
            placeholders <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;,&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">&quot;?&quot;</span> <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> tag_ids)
            where_clauses<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;tag_links.tag_id IN (</span><span style="color: #A45A77; font-weight: bold">{</span>placeholders<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>)
            params<span style="color: #666666">.</span>extend(tag_ids)
            group_by <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; GROUP BY documents.id&quot;</span>
            having <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; HAVING COUNT(DISTINCT tag_links.tag_id) = ?&quot;</span>

        normalized_folder <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_folder(folder) <span style="color: #008000; font-weight: bold">if</span> folder <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">if</span> normalized_folder <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">if</span> recursive:
                where_clauses<span style="color: #666666">.</span>append(
                    <span style="color: #BA2121">&quot;(documents.folder_path = ? OR documents.folder_path LIKE ? ESCAPE &#39;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">&#39;)&quot;</span>
                )
                params<span style="color: #666666">.</span>extend(
                    [
                        normalized_folder,
                        <span style="color: #008000">self</span><span style="color: #666666">.</span>_build_folder_like_pattern(normalized_folder),
                    ]
                )
            <span style="color: #008000; font-weight: bold">else</span>:
                where_clauses<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;documents.folder_path = ?&quot;</span>)
                params<span style="color: #666666">.</span>append(normalized_folder)

        <span style="color: #008000; font-weight: bold">if</span> tag_ids:
            params<span style="color: #666666">.</span>append(<span style="color: #008000">len</span>(tag_ids))

        query <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;SELECT documents.* FROM documents&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> joins:
            query <span style="color: #666666">=</span> <span style="color: #BA2121">&quot; &quot;</span><span style="color: #666666">.</span>join([query] <span style="color: #666666">+</span> joins)
        <span style="color: #008000; font-weight: bold">if</span> where_clauses:
            query <span style="color: #666666">+=</span> <span style="color: #BA2121">&quot; WHERE &quot;</span> <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; AND &quot;</span><span style="color: #666666">.</span>join(where_clauses)
        query <span style="color: #666666">+=</span> group_by <span style="color: #666666">+</span> having <span style="color: #666666">+</span> <span style="color: #BA2121">&quot; ORDER BY documents.created_at ASC&quot;</span>

        rows <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(query, params)<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [record <span style="color: #008000; font-weight: bold">for</span> record <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows) <span style="color: #008000; font-weight: bold">if</span> record]
</code></pre>
<h3 id="update">Method: update(self, document_id: int, **fields: Any) -&gt; dict[str, Any] | None</h3>
<p>The `update` method in the `DocumentRepository` class modifies specified fields of a document identified by `document_id`. It accepts keyword arguments representing the fields to update and their new values. The method processes special fields such as `metadata` (converted to JSON) and `source_path` (normalized and used to derive `folder_path` if not provided). It constructs an SQL `UPDATE` statement to apply the changes and returns the updated document as a dictionary, or `None` if no fields are provided. The update is executed within a transactional context.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">update</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>, <span style="color: #666666">**</span>fields: Any) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> fields:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(document_id)

        updates: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
        values: <span style="color: #008000">list</span>[Any] <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;metadata&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> fields:
            metadata_value <span style="color: #666666">=</span> fields[<span style="color: #BA2121">&quot;metadata&quot;</span>]
            fields[<span style="color: #BA2121">&quot;metadata&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(metadata_value) <span style="color: #008000; font-weight: bold">if</span> metadata_value <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;source_path&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> fields:
            normalized <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_path(fields[<span style="color: #BA2121">&quot;source_path&quot;</span>])
            fields[<span style="color: #BA2121">&quot;source_path&quot;</span>] <span style="color: #666666">=</span> normalized
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;folder_path&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> fields:
                folder_value: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>
                <span style="color: #008000; font-weight: bold">if</span> normalized <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                    folder_value <span style="color: #666666">=</span> Path(normalized)<span style="color: #666666">.</span>parent
                <span style="color: #008000; font-weight: bold">else</span>:
                    folder_value <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
                fields[<span style="color: #BA2121">&quot;folder_path&quot;</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_folder(folder_value)

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;folder_path&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> fields:
            fields[<span style="color: #BA2121">&quot;folder_path&quot;</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_folder(fields[<span style="color: #BA2121">&quot;folder_path&quot;</span>])

        <span style="color: #008000; font-weight: bold">for</span> key, value <span style="color: #AA22FF; font-weight: bold">in</span> fields<span style="color: #666666">.</span>items():
            updates<span style="color: #666666">.</span>append(<span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>key<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> = ?&quot;</span>)
            values<span style="color: #666666">.</span>append(value)
        values<span style="color: #666666">.</span>append(document_id)

        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">f&quot;UPDATE documents SET </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join(updates)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> WHERE id = ?&quot;</span>,
                values,
            )
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(document_id)
</code></pre>
<h3 id="delete">Method: delete(self, document_id: int) -&gt; None</h3>
<p>The `delete` function removes a document from the repository based on its ID. It first retrieves all tag IDs associated with the document. Then, within a database transaction, it deletes the document and updates the document count for each associated tag, ensuring the count does not go below zero.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">delete</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        tag_ids <span style="color: #666666">=</span> [tag[<span style="color: #BA2121">&quot;id&quot;</span>] <span style="color: #008000; font-weight: bold">for</span> tag <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>list_tags_for_document(document_id)]
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;DELETE FROM documents WHERE id = ?&quot;</span>, (document_id,))
            <span style="color: #008000; font-weight: bold">if</span> tag_ids:
                connection<span style="color: #666666">.</span>executemany(
<span style="color: #bbbbbb">                    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                    UPDATE tags</span>
<span style="color: #BA2121; font-style: italic">                    SET document_count = CASE</span>
<span style="color: #BA2121; font-style: italic">                        WHEN document_count &gt; 0 THEN document_count - 1</span>
<span style="color: #BA2121; font-style: italic">                        ELSE 0</span>
<span style="color: #BA2121; font-style: italic">                    END</span>
<span style="color: #BA2121; font-style: italic">                    WHERE id = ?</span>
<span style="color: #BA2121; font-style: italic">                    &quot;&quot;&quot;</span>,
                    [(tag_id,) <span style="color: #008000; font-weight: bold">for</span> tag_id <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">set</span>(tag_ids)],
                )
</code></pre>
<h3 id="add_file_version">Method: add_file_version(self, document_id: int, *, file_path: str | Path, checksum: str | None=None, file_size: int | None=None) -&gt; dict[str, Any]</h3>
<p>The function `add_file_version` inserts a new file version record into the `file_versions` table in the database. It calculates the next version number for the given document ID by selecting the maximum existing version and incrementing it by one. The function then executes an insert operation with the provided document ID, calculated version, resolved file path, checksum, and file size. After the insertion, it retrieves and returns the newly created file version record using the `get_file_version` method. The operation is wrapped in a transaction to ensure data consistency.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">add_file_version</span>(
        <span style="color: #008000">self</span>,
        document_id: <span style="color: #008000">int</span>,
        <span style="color: #666666">*</span>,
        file_path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path,
        checksum: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        file_size: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()
        row <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT COALESCE(MAX(version), 0) + 1 FROM file_versions WHERE document_id = ?&quot;</span>,
            (document_id,),
        )<span style="color: #666666">.</span>fetchone()
        version <span style="color: #666666">=</span> <span style="color: #008000">int</span>(row[<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> tx:
            cursor <span style="color: #666666">=</span> tx<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO file_versions (document_id, version, file_path, checksum, file_size)</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (
                    document_id,
                    version,
                    <span style="color: #008000">str</span>(Path(file_path)<span style="color: #666666">.</span>resolve()),
                    checksum,
                    file_size,
                ),
            )
            version_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_file_version(version_id)
</code></pre>
<h3 id="get_file_version">Method: get_file_version(self, version_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a specific file version from the database by its ID and returns it as a dictionary. If no matching record is found, returns None.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_file_version</span>(<span style="color: #008000">self</span>, version_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM file_versions WHERE id = ?&quot;</span>, (version_id,)
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
</code></pre>
<h3 id="list_file_versions">Method: list_file_versions(self, document_id: int) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_file_versions` retrieves all versions of a specified document from the database, ordered by version number in ascending order. It takes a `document_id` as input and returns a list of dictionaries, where each dictionary represents a row from the `file_versions` table corresponding to the given document ID. Each dictionary is constructed using the `_row_to_dict` method, which converts a database row into a dictionary format. The function filters out any null rows before returning the results.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_file_versions</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM file_versions WHERE document_id = ? ORDER BY version ASC&quot;</span>,
            (document_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="create_tag">Method: create_tag(self, project_id: int, name: str, description: str | None=None, color: str | None=None) -&gt; dict[str, Any]</h3>
<p>The function `create_tag` inserts a new tag into the `tags` table of the database, associating it with a specified project. It accepts parameters for `project_id`, `name`, `description`, and `color`. The function executes an SQL `INSERT` statement to add the tag, retrieves the ID of the newly inserted row, and returns the created tag by calling `self.get_tag(tag_id)`. The operation is performed within a database transaction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create_tag</span>(
        <span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>, name: <span style="color: #008000">str</span>, description: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>, color: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;INSERT INTO tags (project_id, name, description, color) VALUES (?, ?, ?, ?)&quot;</span>,
                (project_id, name, description, color),
            )
            tag_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_tag(tag_id)
</code></pre>
<h3 id="get_tag">Method: get_tag(self, tag_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a tag from the database by its ID and returns it as a dictionary, or None if not found.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_tag</span>(<span style="color: #008000">self</span>, tag_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM tags WHERE id = ?&quot;</span>, (tag_id,)
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
</code></pre>
<h3 id="tag_document">Method: tag_document(self, document_id: int, tag_id: int) -&gt; None</h3>
<p>The function `tag_document` associates a document with a tag by inserting a record into the `tag_links` table. If the insertion is successful (indicated by `cursor.rowcount`), it updates the `document_count` field in the `tags` table to reflect the addition of the document to the tag. The operation is executed within a database transaction to ensure data consistency.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tag_document</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>, tag_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;INSERT OR IGNORE INTO tag_links (tag_id, document_id) VALUES (?, ?)&quot;</span>,
                (tag_id, document_id),
            )
            <span style="color: #008000; font-weight: bold">if</span> cursor<span style="color: #666666">.</span>rowcount:
                connection<span style="color: #666666">.</span>execute(
                    <span style="color: #BA2121">&quot;UPDATE tags SET document_count = document_count + 1 WHERE id = ?&quot;</span>,
                    (tag_id,),
                )
</code></pre>
<h3 id="untag_document">Method: untag_document(self, document_id: int, tag_id: int) -&gt; None</h3>
<p>The function `untag_document` removes the association between a specified document and tag in the repository. It performs the following actions within a database transaction:

1. Deletes the record from the `tag_links` table where the `tag_id` and `document_id` match the provided values.
2. If the deletion affects rows (i.e., the link existed), it updates the `tags` table to decrement the `document_count` for the specified tag, ensuring it does not go below zero.

This function is used to remove a tag from a document and adjust the tag&#x27;s document count accordingly.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">untag_document</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>, tag_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;DELETE FROM tag_links WHERE tag_id = ? AND document_id = ?&quot;</span>,
                (tag_id, document_id),
            )
            <span style="color: #008000; font-weight: bold">if</span> cursor<span style="color: #666666">.</span>rowcount:
                connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                    UPDATE tags</span>
<span style="color: #BA2121; font-style: italic">                    SET document_count = CASE</span>
<span style="color: #BA2121; font-style: italic">                        WHEN document_count &gt; 0 THEN document_count - 1</span>
<span style="color: #BA2121; font-style: italic">                        ELSE 0</span>
<span style="color: #BA2121; font-style: italic">                    END</span>
<span style="color: #BA2121; font-style: italic">                    WHERE id = ?</span>
<span style="color: #BA2121; font-style: italic">                    &quot;&quot;&quot;</span>,
                    (tag_id,),
                )
</code></pre>
<h3 id="list_tags_for_document">Method: list_tags_for_document(self, document_id: int) -&gt; list[dict[str, Any]]</h3>
<p>Returns a list of tag dictionaries associated with a specified document ID, ordered by tag name. The function retrieves tags from the database by joining the `tags` table with the `tag_links` table, filtering by the provided document ID. Each tag is converted to a dictionary using the `_row_to_dict` helper method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_tags_for_document</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">            </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">            SELECT tags.*</span>
<span style="color: #BA2121; font-style: italic">            FROM tags</span>
<span style="color: #BA2121; font-style: italic">            INNER JOIN tag_links ON tag_links.tag_id = tags.id</span>
<span style="color: #BA2121; font-style: italic">            WHERE tag_links.document_id = ?</span>
<span style="color: #BA2121; font-style: italic">            ORDER BY tags.name ASC</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>,
            (document_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="list_tags_for_project">Method: list_tags_for_project(self, project_id: int) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_tags_for_project` retrieves all tags associated with a specified project from the database. It executes a SQL query to select all columns from the `tags` table where the `project_id` matches the provided argument, ordering the results by tag name in ascending order. Each retrieved row is converted into a dictionary using a helper method `_row_to_dict`, and the resulting list of dictionaries is returned. The function filters out any null rows before processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_tags_for_project</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM tags WHERE project_id = ? ORDER BY name ASC&quot;</span>,
            (project_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="delete_tag">Method: delete_tag(self, tag_id: int) -&gt; None</h3>
<p>The function `delete_tag` removes a tag from the repository by its ID. It executes a SQL DELETE statement within a database transaction to remove the row corresponding to the specified `tag_id` from the `tags` table.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">delete_tag</span>(<span style="color: #008000">self</span>, tag_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;DELETE FROM tags WHERE id = ?&quot;</span>, (tag_id,))
</code></pre>
<h3 id="refresh_tag_counts">Method: refresh_tag_counts(self, project_id: int | None=None) -&gt; None</h3>
<p>The `refresh_tag_counts` function updates the `document_count` field in the `tags` table to reflect the number of documents associated with each tag. If no `project_id` is provided, it updates counts for all tags across the database. If a `project_id` is specified, it updates counts only for tags within that project, considering only documents belonging to the specified project. The function uses SQL queries to calculate and assign the counts based on the relationships defined in the `tag_links` and `documents` tables.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">refresh_tag_counts</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        connection <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()
        <span style="color: #008000; font-weight: bold">if</span> project_id <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                UPDATE tags</span>
<span style="color: #BA2121; font-style: italic">                SET document_count = (</span>
<span style="color: #BA2121; font-style: italic">                    SELECT COUNT(*) FROM tag_links WHERE tag_links.tag_id = tags.id</span>
<span style="color: #BA2121; font-style: italic">                )</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>
            )
            <span style="color: #008000; font-weight: bold">return</span>
        connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">            </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">            UPDATE tags</span>
<span style="color: #BA2121; font-style: italic">            SET document_count = (</span>
<span style="color: #BA2121; font-style: italic">                SELECT COUNT(*)</span>
<span style="color: #BA2121; font-style: italic">                FROM tag_links</span>
<span style="color: #BA2121; font-style: italic">                INNER JOIN documents ON documents.id = tag_links.document_id</span>
<span style="color: #BA2121; font-style: italic">                WHERE tag_links.tag_id = tags.id AND documents.project_id = ?</span>
<span style="color: #BA2121; font-style: italic">            )</span>
<span style="color: #BA2121; font-style: italic">            WHERE project_id = ?</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>,
            (project_id, project_id),
        )
</code></pre>
<h3 id="_normalize_path">Method: _normalize_path(path: str | Path | None) -&gt; str | None</h3>
<p>The function `_normalize_path` takes a path input, which can be a string, `Path` object, or `None`, and returns a normalized string representation of the path. If the input is `None`, it returns `None`. Otherwise, it resolves the path to its absolute form using `Path.resolve()` and converts it to a string.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_normalize_path</span>(path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> path <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve())
</code></pre>
<h3 id="_normalize_folder">Method: _normalize_folder(path: str | Path | None) -&gt; str | None</h3>
<p>The function `_normalize_folder` takes a path input, which can be a string, `Path` object, or `None`, and returns a normalized string representation of the resolved path. If the input is `None` or an empty string, it returns `None`. Otherwise, it resolves the path to its absolute form and converts it to a string.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_normalize_folder</span>(path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> path <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000; font-weight: bold">None</span>, <span style="color: #BA2121">&quot;&quot;</span>):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve())
</code></pre>
<h3 id="_build_folder_like_pattern">Method: _build_folder_like_pattern(folder: str) -&gt; str</h3>
<p>The function `_build_folder_like_pattern` constructs a string pattern for database queries that matches files or folders within a specified directory path. It sanitizes the input folder path by escaping special characters `%` and `_` to prevent unintended wildcard matching in SQL LIKE clauses. If the folder path ends with a path separator (`/` or `\`), it appends a `%` to match all contents within that folder. Otherwise, it determines the appropriate path separator based on the input and appends the separator followed by `%` to match items in the specified directory. The resulting pattern is designed for use in SQL queries to filter paths that are children of the given folder.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_build_folder_like_pattern</span>(folder: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        sanitized <span style="color: #666666">=</span> folder<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;%&quot;</span>, <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">%&quot;</span>)<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&quot;_&quot;</span>, <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">_&quot;</span>)
        <span style="color: #008000; font-weight: bold">if</span> sanitized<span style="color: #666666">.</span>endswith((<span style="color: #BA2121">&quot;/&quot;</span>, <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">&quot;</span>)):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>sanitized<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">%&quot;</span>
        separator <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">&quot;</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&quot;</span><span style="color: #AA5D1F; font-weight: bold">\\</span><span style="color: #BA2121">&quot;</span> <span style="color: #AA22FF; font-weight: bold">in</span> folder <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #BA2121">&quot;/&quot;</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF; font-weight: bold">in</span> folder <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&quot;/&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">f&quot;</span><span style="color: #A45A77; font-weight: bold">{</span>sanitized<span style="color: #A45A77; font-weight: bold">}{</span>separator<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">%&quot;</span>
</code></pre>
<h3 id="_decode_document_row">Method: _decode_document_row(row: sqlite3.Row | None) -&gt; dict[str, Any] | None</h3>
<p>The function `_decode_document_row` converts a SQLite database row into a dictionary representation. It takes a row from a SQLite query result and maps its columns to keys in a dictionary. If the row is `None`, it returns `None`. For rows with metadata, it parses the metadata column from a JSON string into a Python dictionary. The function ensures that all column values are included in the returned dictionary, with proper handling of the metadata field.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_decode_document_row</span>(row: sqlite3<span style="color: #666666">.</span>Row <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        record <span style="color: #666666">=</span> {key: row[key] <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> row<span style="color: #666666">.</span>keys()}
        <span style="color: #008000; font-weight: bold">if</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;metadata&quot;</span>):
            record[<span style="color: #BA2121">&quot;metadata&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;metadata&quot;</span>])
        <span style="color: #008000; font-weight: bold">return</span> record
</code></pre>
<h2 id="IngestDocumentRepository">Class: IngestDocumentRepository</h2>
<p>The `IngestDocumentRepository` class provides methods to store, retrieve, and search parsed document data, including text, metadata, sections, pages, and search indexes. It handles versioning of documents by path, manages document chunks for full-text search, and supports deletion of documents and their associated search indices. The class includes functionality for normalizing text, building previews, and performing search queries against indexed document content.</p>
<h3 id="store_version">Method: store_version(self, *, path: str, checksum: str | None, size: int | None, mtime: float | None, ctime: float | None, parsed: &#x27;ParsedDocument&#x27;, base_metadata: dict[str, Any] | None=None) -&gt; dict[str, Any]</h3>
<p>The `store_version` method stores a versioned representation of a parsed document into the database. It computes metadata, normalized text, and preview content from the input `ParsedDocument`, then inserts this data into the `ingest_documents` table with a new version number derived from existing entries for the same path. If prior versions exist, it removes their associated chunks and replaces them with new chunks based on the current document&#x27;s text. The method returns the stored document record.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">store_version</span>(
        <span style="color: #008000">self</span>,
        <span style="color: #666666">*</span>,
        path: <span style="color: #008000">str</span>,
        checksum: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>,
        size: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>,
        mtime: <span style="color: #008000">float</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>,
        ctime: <span style="color: #008000">float</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>,
        parsed: <span style="color: #BA2121">&quot;ParsedDocument&quot;</span>,
        base_metadata: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        normalized_path <span style="color: #666666">=</span> <span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve())
        metadata <span style="color: #666666">=</span> <span style="color: #008000">dict</span>(base_metadata <span style="color: #AA22FF; font-weight: bold">or</span> {})
        metadata<span style="color: #666666">.</span>update(parsed<span style="color: #666666">.</span>metadata)
        metadata_json <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(metadata, ensure_ascii<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        sections_json <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(
            [section<span style="color: #666666">.</span>to_dict() <span style="color: #008000; font-weight: bold">for</span> section <span style="color: #AA22FF; font-weight: bold">in</span> parsed<span style="color: #666666">.</span>sections], ensure_ascii<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>
        )
        pages_json <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps([page<span style="color: #666666">.</span>to_dict() <span style="color: #008000; font-weight: bold">for</span> page <span style="color: #AA22FF; font-weight: bold">in</span> parsed<span style="color: #666666">.</span>pages], ensure_ascii<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
        normalized_text <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_text(parsed<span style="color: #666666">.</span>text)
        preview <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_build_preview(normalized_text)
        ocr_message <span style="color: #666666">=</span> parsed<span style="color: #666666">.</span>ocr_hint <span style="color: #008000; font-weight: bold">if</span> parsed<span style="color: #666666">.</span>needs_ocr <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>

        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            existing_rows <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;SELECT id FROM ingest_documents WHERE path = ?&quot;</span>,
                (normalized_path,),
            )<span style="color: #666666">.</span>fetchall()
            previous_ids <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;id&quot;</span>]) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> existing_rows]
            row <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                SELECT version</span>
<span style="color: #BA2121; font-style: italic">                FROM ingest_documents</span>
<span style="color: #BA2121; font-style: italic">                WHERE path = ?</span>
<span style="color: #BA2121; font-style: italic">                ORDER BY version DESC</span>
<span style="color: #BA2121; font-style: italic">                LIMIT 1</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (normalized_path,),
            )<span style="color: #666666">.</span>fetchone()
            version <span style="color: #666666">=</span> <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;version&quot;</span>]) <span style="color: #666666">+</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO ingest_documents (</span>
<span style="color: #BA2121; font-style: italic">                    path, version, checksum, size, mtime, ctime, metadata, text,</span>
<span style="color: #BA2121; font-style: italic">                    normalized_text, preview, sections, pages, needs_ocr, ocr_message</span>
<span style="color: #BA2121; font-style: italic">                )</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (
                    normalized_path,
                    version,
                    checksum,
                    size,
                    mtime,
                    ctime,
                    metadata_json,
                    parsed<span style="color: #666666">.</span>text,
                    normalized_text,
                    preview,
                    sections_json,
                    pages_json,
                    <span style="color: #008000">int</span>(parsed<span style="color: #666666">.</span>needs_ocr),
                    ocr_message,
                ),
            )
            document_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
            <span style="color: #008000; font-weight: bold">if</span> previous_ids:
                <span style="color: #008000">self</span><span style="color: #666666">.</span>_delete_chunks_for_documents(connection, previous_ids)
            <span style="color: #008000">self</span><span style="color: #666666">.</span>_replace_chunks(
                connection,
                document_id,
                normalized_path,
                parsed<span style="color: #666666">.</span>text,
                normalized_text,
            )
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(document_id)
</code></pre>
<h3 id="get">Method: get(self, document_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a document from the database by its ID and returns it as a dictionary, or None if not found. The document data is decoded from the database row using the `_decode_document_row` method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get</span>(<span style="color: #008000">self</span>, document_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM ingest_documents WHERE id = ?&quot;</span>,
            (document_id,),
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row)
</code></pre>
<h3 id="get_latest_by_path">Method: get_latest_by_path(self, path: str | Path) -&gt; dict[str, Any] | None</h3>
<p>Retrieves the latest version of a document entry from the `ingest_documents` table based on the specified file path. The path is normalized to its absolute form, and the query fetches the most recent entry by `version`, returning it as a decoded dictionary or `None` if no matching record is found.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_latest_by_path</span>(<span style="color: #008000">self</span>, path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        normalized_path <span style="color: #666666">=</span> <span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve())
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">            </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">            SELECT * FROM ingest_documents</span>
<span style="color: #BA2121; font-style: italic">            WHERE path = ?</span>
<span style="color: #BA2121; font-style: italic">            ORDER BY version DESC</span>
<span style="color: #BA2121; font-style: italic">            LIMIT 1</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>,
            (normalized_path,),
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row)
</code></pre>
<h3 id="list_versions">Method: list_versions(self, path: str | Path) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_versions` retrieves all versions of a document stored in the database, identified by its file path. It takes a file path as input, normalizes it to an absolute string, and queries the `ingest_documents` table for records matching that path. The results are ordered by version in descending order. Each retrieved row is decoded into a dictionary format using a helper method `_decode_document_row`, and only non-null records are included in the final list, which is returned as a list of dictionaries.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_versions</span>(<span style="color: #008000">self</span>, path: <span style="color: #008000">str</span> <span style="color: #666666">|</span> Path) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        normalized_path <span style="color: #666666">=</span> <span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve())
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">            </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">            SELECT * FROM ingest_documents</span>
<span style="color: #BA2121; font-style: italic">            WHERE path = ?</span>
<span style="color: #BA2121; font-style: italic">            ORDER BY version DESC</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>,
            (normalized_path,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [record <span style="color: #008000; font-weight: bold">for</span> record <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows) <span style="color: #008000; font-weight: bold">if</span> record]
</code></pre>
<h3 id="list_all">Method: list_all(self) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_all` retrieves all records from the `ingest_documents` table in the database, ordered by creation date in ascending order. It fetches all rows, decodes each row into a document dictionary using `_decode_document_row`, and filters out any None or invalid records. The result is a list of dictionaries representing the ingested documents.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_all</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM ingest_documents ORDER BY created_at ASC&quot;</span>,
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [record <span style="color: #008000; font-weight: bold">for</span> record <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_document_row(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows) <span style="color: #008000; font-weight: bold">if</span> record]
</code></pre>
<h3 id="delete_by_paths">Method: delete_by_paths(self, paths: Iterable[str | Path]) -&gt; int</h3>
<p>The function `delete_by_paths` removes all ingest records from the database that are associated with the provided file paths. It accepts an iterable of paths, normalizes them to absolute form, and ensures uniqueness before processing. For each unique path, it identifies corresponding document IDs in the `ingest_documents` table, deletes related chunks using `_delete_chunks_for_documents`, and then removes the document records. The function returns the total count of deleted rows across both the `ingest_documents` table and its associated FTS index. If no valid paths are provided, it returns zero.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">delete_by_paths</span>(<span style="color: #008000">self</span>, paths: Iterable[<span style="color: #008000">str</span> <span style="color: #666666">|</span> Path]) <span style="color: #666666">-&gt;</span> <span style="color: #008000">int</span>:
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Remove all ingest records associated with ``paths``.</span>

<span style="color: #BA2121; font-style: italic">        Returns the number of rows deleted across both the ingest table and the</span>
<span style="color: #BA2121; font-style: italic">        associated FTS index. Paths are normalised to absolute form before</span>
<span style="color: #BA2121; font-style: italic">        matching so callers can provide either relative or absolute values.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>

        normalized <span style="color: #666666">=</span> [<span style="color: #008000">str</span>(Path(path)<span style="color: #666666">.</span>resolve()) <span style="color: #008000; font-weight: bold">for</span> path <span style="color: #AA22FF; font-weight: bold">in</span> paths]
        unique_paths <span style="color: #666666">=</span> <span style="color: #008000">list</span>(<span style="color: #008000">dict</span><span style="color: #666666">.</span>fromkeys(normalized))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> unique_paths:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>

        removed <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            <span style="color: #008000; font-weight: bold">for</span> path <span style="color: #AA22FF; font-weight: bold">in</span> unique_paths:
                rows <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                    <span style="color: #BA2121">&quot;SELECT id FROM ingest_documents WHERE path = ?&quot;</span>,
                    (path,),
                )<span style="color: #666666">.</span>fetchall()
                document_ids <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;id&quot;</span>]) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows]
                <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> document_ids:
                    <span style="color: #008000; font-weight: bold">continue</span>
                <span style="color: #008000">self</span><span style="color: #666666">.</span>_delete_chunks_for_documents(connection, document_ids)
                placeholders <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;,&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">&quot;?&quot;</span> <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> document_ids)
                connection<span style="color: #666666">.</span>execute(
                    <span style="color: #BA2121">f&quot;DELETE FROM ingest_documents WHERE id IN (</span><span style="color: #A45A77; font-weight: bold">{</span>placeholders<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>,
                    document_ids,
                )
                removed <span style="color: #666666">+=</span> <span style="color: #008000">len</span>(document_ids)
        <span style="color: #008000; font-weight: bold">return</span> removed
</code></pre>
<h3 id="search">Method: search(self, query: str, *, limit: int=5) -&gt; list[dict[str, Any]]</h3>
<p>The function `search` in the `IngestDocumentRepository` class performs a document search operation based on a provided query string. It accepts a query parameter of type `str` and an optional `limit` parameter of type `int` with a default value of 5. The function delegates the search functionality to the `search_chunks` method, passing along the query and limit parameters, and returns a list of dictionaries containing the search results. Each dictionary in the returned list represents a chunk of text that matches the query, along with associated metadata.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">search</span>(<span style="color: #008000">self</span>, query: <span style="color: #008000">str</span>, <span style="color: #666666">*</span>, limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">5</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>search_chunks(query, limit<span style="color: #666666">=</span>limit)
</code></pre>
<h3 id="search_chunks">Method: search_chunks(self, query: str, *, limit: int=5) -&gt; list[dict[str, Any]]</h3>
<p>The function `search_chunks` retrieves indexed document chunks matching a given query, returning a list of dictionaries containing chunk details, associated document information, highlighted snippets, and relevance scores. It uses SQLite&#x27;s full-text search capabilities to find matches, orders results by score and chunk index, and limits the output based on a specified number of results. The function joins indexed data with chunk text and metadata, and includes logic to fetch related document information for each matched chunk.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">search_chunks</span>(<span style="color: #008000">self</span>, query: <span style="color: #008000">str</span>, <span style="color: #666666">*</span>, limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">5</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">            </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">            SELECT</span>
<span style="color: #BA2121; font-style: italic">                ingest_document_index.rowid AS chunk_id,</span>
<span style="color: #BA2121; font-style: italic">                ingest_document_index.document_id AS document_id,</span>
<span style="color: #BA2121; font-style: italic">                ingest_document_index.chunk_index AS chunk_index,</span>
<span style="color: #BA2121; font-style: italic">                ingest_document_index.path AS path,</span>
<span style="color: #BA2121; font-style: italic">                highlight(ingest_document_index, 0, &#39;&lt;mark&gt;&#39;, &#39;&lt;/mark&gt;&#39;) AS snippet,</span>
<span style="color: #BA2121; font-style: italic">                bm25(ingest_document_index) AS score,</span>
<span style="color: #BA2121; font-style: italic">                chunks.text AS chunk_text,</span>
<span style="color: #BA2121; font-style: italic">                chunks.token_count AS token_count,</span>
<span style="color: #BA2121; font-style: italic">                chunks.start_offset AS start_offset,</span>
<span style="color: #BA2121; font-style: italic">                chunks.end_offset AS end_offset</span>
<span style="color: #BA2121; font-style: italic">            FROM ingest_document_index</span>
<span style="color: #BA2121; font-style: italic">            INNER JOIN ingest_document_chunks AS chunks ON chunks.id = ingest_document_index.rowid</span>
<span style="color: #BA2121; font-style: italic">            WHERE ingest_document_index MATCH ?</span>
<span style="color: #BA2121; font-style: italic">            ORDER BY score ASC, chunk_index ASC</span>
<span style="color: #BA2121; font-style: italic">            LIMIT ?</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>,
            (query, limit),
        )<span style="color: #666666">.</span>fetchall()

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> rows:
            <span style="color: #008000; font-weight: bold">return</span> []

        document_ids <span style="color: #666666">=</span> {<span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;document_id&quot;</span>]) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows}
        documents: <span style="color: #008000">dict</span>[<span style="color: #008000">int</span>, <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> {}
        <span style="color: #008000; font-weight: bold">for</span> doc_id <span style="color: #AA22FF; font-weight: bold">in</span> document_ids:
            document <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(doc_id)
            <span style="color: #008000; font-weight: bold">if</span> document <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
                documents[doc_id] <span style="color: #666666">=</span> document

        results: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows:
            doc_id <span style="color: #666666">=</span> <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;document_id&quot;</span>])
            document <span style="color: #666666">=</span> documents<span style="color: #666666">.</span>get(doc_id)
            <span style="color: #008000; font-weight: bold">if</span> document <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #008000; font-weight: bold">continue</span>
            chunk <span style="color: #666666">=</span> {
                <span style="color: #BA2121">&quot;id&quot;</span>: <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;chunk_id&quot;</span>]),
                <span style="color: #BA2121">&quot;document_id&quot;</span>: doc_id,
                <span style="color: #BA2121">&quot;index&quot;</span>: <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;chunk_index&quot;</span>]),
                <span style="color: #BA2121">&quot;text&quot;</span>: row[<span style="color: #BA2121">&quot;chunk_text&quot;</span>],
                <span style="color: #BA2121">&quot;token_count&quot;</span>: <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;token_count&quot;</span>]),
                <span style="color: #BA2121">&quot;start_offset&quot;</span>: <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;start_offset&quot;</span>]),
                <span style="color: #BA2121">&quot;end_offset&quot;</span>: <span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;end_offset&quot;</span>]),
            }
            results<span style="color: #666666">.</span>append(
                {
                    <span style="color: #BA2121">&quot;chunk&quot;</span>: chunk,
                    <span style="color: #BA2121">&quot;document&quot;</span>: document,
                    <span style="color: #BA2121">&quot;highlight&quot;</span>: row[<span style="color: #BA2121">&quot;snippet&quot;</span>],
                    <span style="color: #BA2121">&quot;score&quot;</span>: <span style="color: #008000">float</span>(row[<span style="color: #BA2121">&quot;score&quot;</span>]),
                    <span style="color: #BA2121">&quot;path&quot;</span>: document<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;path&quot;</span>),
                }
            )
        <span style="color: #008000; font-weight: bold">return</span> results
</code></pre>
<h3 id="_normalize_text">Method: _normalize_text(text: str) -&gt; str</h3>
<p>The function `_normalize_text` takes a string input and normalizes it by replacing all sequences of whitespace characters with a single space, then strips leading and trailing whitespace from the result.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_normalize_text</span>(text: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        collapsed <span style="color: #666666">=</span> re<span style="color: #666666">.</span>sub(<span style="color: #BA2121">r&quot;\s+&quot;</span>, <span style="color: #BA2121">&quot; &quot;</span>, text<span style="color: #666666">.</span>strip())
        <span style="color: #008000; font-weight: bold">return</span> collapsed
</code></pre>
<h3 id="_delete_chunks_for_documents">Method: _delete_chunks_for_documents(self, connection: sqlite3.Connection, document_ids: Iterable[int]) -&gt; None</h3>
<p>The function `_delete_chunks_for_documents` removes all chunks and their associated index entries for a given set of document IDs from the database. It first retrieves the IDs of chunks linked to the specified documents, then deletes those chunks from both the `ingest_document_index` and `ingest_document_chunks` tables. The operation is performed within a provided SQLite database connection.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_delete_chunks_for_documents</span>(
        <span style="color: #008000">self</span>, connection: sqlite3<span style="color: #666666">.</span>Connection, document_ids: Iterable[<span style="color: #008000">int</span>]
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        doc_ids <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(doc_id) <span style="color: #008000; font-weight: bold">for</span> doc_id <span style="color: #AA22FF; font-weight: bold">in</span> document_ids]
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> doc_ids:
            <span style="color: #008000; font-weight: bold">return</span>
        placeholders <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;,&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">&quot;?&quot;</span> <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> doc_ids)
        rows <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;SELECT id FROM ingest_document_chunks WHERE document_id IN (</span><span style="color: #A45A77; font-weight: bold">{</span>placeholders<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>,
            doc_ids,
        )<span style="color: #666666">.</span>fetchall()
        chunk_ids <span style="color: #666666">=</span> [<span style="color: #008000">int</span>(row[<span style="color: #BA2121">&quot;id&quot;</span>]) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows]
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> chunk_ids:
            <span style="color: #008000; font-weight: bold">return</span>
        chunk_placeholders <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;,&quot;</span><span style="color: #666666">.</span>join(<span style="color: #BA2121">&quot;?&quot;</span> <span style="color: #008000; font-weight: bold">for</span> _ <span style="color: #AA22FF; font-weight: bold">in</span> chunk_ids)
        connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;DELETE FROM ingest_document_index WHERE rowid IN (</span><span style="color: #A45A77; font-weight: bold">{</span>chunk_placeholders<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>,
            chunk_ids,
        )
        connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;DELETE FROM ingest_document_chunks WHERE id IN (</span><span style="color: #A45A77; font-weight: bold">{</span>chunk_placeholders<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121">)&quot;</span>,
            chunk_ids,
        )
</code></pre>
<h3 id="_replace_chunks">Method: _replace_chunks(self, connection: sqlite3.Connection, document_id: int, path: str, text: str, normalized_text: str) -&gt; None</h3>
<p>The function `_replace_chunks` replaces the chunks of a document in the database with new chunks generated from the provided text. It first deletes existing chunks associated with the given `document_id`, then inserts the newly chunked content into the `ingest_document_chunks` table. For each chunk, it also inserts corresponding entries into the `ingest_document_index` table to support search functionality. The function uses a database connection to perform these operations and ensures that the chunked data is properly indexed for retrieval.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_replace_chunks</span>(
        <span style="color: #008000">self</span>,
        connection: sqlite3<span style="color: #666666">.</span>Connection,
        document_id: <span style="color: #008000">int</span>,
        path: <span style="color: #008000">str</span>,
        text: <span style="color: #008000">str</span>,
        normalized_text: <span style="color: #008000">str</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        chunks <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_chunk_document(text, normalized_text<span style="color: #666666">=</span>normalized_text)
        connection<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;DELETE FROM ingest_document_chunks WHERE document_id = ?&quot;</span>,
            (document_id,),
        )
        <span style="color: #008000; font-weight: bold">for</span> chunk <span style="color: #AA22FF; font-weight: bold">in</span> chunks:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO ingest_document_chunks (</span>
<span style="color: #BA2121; font-style: italic">                    document_id, chunk_index, text, token_count, start_offset, end_offset</span>
<span style="color: #BA2121; font-style: italic">                )</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (
                    document_id,
                    chunk[<span style="color: #BA2121">&quot;index&quot;</span>],
                    chunk[<span style="color: #BA2121">&quot;text&quot;</span>],
                    chunk[<span style="color: #BA2121">&quot;token_count&quot;</span>],
                    chunk[<span style="color: #BA2121">&quot;start_offset&quot;</span>],
                    chunk[<span style="color: #BA2121">&quot;end_offset&quot;</span>],
                ),
            )
            chunk_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
            connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO ingest_document_index (</span>
<span style="color: #BA2121; font-style: italic">                    rowid, content, path, document_id, chunk_id, chunk_index</span>
<span style="color: #BA2121; font-style: italic">                )</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (
                    chunk_id,
                    chunk[<span style="color: #BA2121">&quot;search_text&quot;</span>],
                    path,
                    document_id,
                    chunk_id,
                    chunk[<span style="color: #BA2121">&quot;index&quot;</span>],
                ),
            )
</code></pre>
<h3 id="_chunk_document">Method: _chunk_document(self, text: str, *, normalized_text: str, max_tokens: int=200, overlap: int=40) -&gt; list[dict[str, Any]]</h3>
<p>The function `_chunk_document` splits input text into overlapping token-based chunks for processing. It takes a string `text`, normalized text, and parameters for maximum tokens per chunk and overlap. The function uses regex to find non-whitespace sequences as tokens, then iteratively builds chunks with specified overlap. Each chunk includes metadata such as index, text content, token count, and offset positions. If the input text is empty or contains no tokens, it returns a single chunk using the normalized text. The final chunk list is returned with all chunks properly indexed and formatted.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_chunk_document</span>(
        <span style="color: #008000">self</span>, text: <span style="color: #008000">str</span>, <span style="color: #666666">*</span>, normalized_text: <span style="color: #008000">str</span>, max_tokens: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">200</span>, overlap: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">40</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        max_tokens <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #666666">1</span>, <span style="color: #008000">int</span>(max_tokens))
        overlap <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #666666">0</span>, <span style="color: #008000">min</span>(<span style="color: #008000">int</span>(overlap), max_tokens <span style="color: #666666">-</span> <span style="color: #666666">1</span>))
        matches <span style="color: #666666">=</span> <span style="color: #008000">list</span>(re<span style="color: #666666">.</span>finditer(<span style="color: #BA2121">r&quot;\S+&quot;</span>, text))
        chunks: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> matches:
            trimmed <span style="color: #666666">=</span> text<span style="color: #666666">.</span>strip()
            chunk_text <span style="color: #666666">=</span> trimmed <span style="color: #008000; font-weight: bold">if</span> trimmed <span style="color: #008000; font-weight: bold">else</span> normalized_text
            chunks<span style="color: #666666">.</span>append(
                {
                    <span style="color: #BA2121">&quot;index&quot;</span>: <span style="color: #666666">0</span>,
                    <span style="color: #BA2121">&quot;text&quot;</span>: chunk_text,
                    <span style="color: #BA2121">&quot;token_count&quot;</span>: <span style="color: #666666">0</span>,
                    <span style="color: #BA2121">&quot;start_offset&quot;</span>: <span style="color: #666666">0</span>,
                    <span style="color: #BA2121">&quot;end_offset&quot;</span>: <span style="color: #008000">len</span>(chunk_text),
                    <span style="color: #BA2121">&quot;search_text&quot;</span>: <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_text(chunk_text),
                }
            )
            <span style="color: #008000; font-weight: bold">return</span> chunks

        step <span style="color: #666666">=</span> max_tokens <span style="color: #666666">-</span> overlap <span style="color: #008000; font-weight: bold">if</span> max_tokens <span style="color: #666666">&gt;</span> overlap <span style="color: #008000; font-weight: bold">else</span> max_tokens
        start_token <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        chunk_index <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        text_length <span style="color: #666666">=</span> <span style="color: #008000">len</span>(text)

        <span style="color: #008000; font-weight: bold">while</span> start_token <span style="color: #666666">&lt;</span> <span style="color: #008000">len</span>(matches):
            end_token <span style="color: #666666">=</span> <span style="color: #008000">min</span>(start_token <span style="color: #666666">+</span> max_tokens, <span style="color: #008000">len</span>(matches))
            start_offset <span style="color: #666666">=</span> matches[start_token]<span style="color: #666666">.</span>start()
            end_offset <span style="color: #666666">=</span> matches[end_token <span style="color: #666666">-</span> <span style="color: #666666">1</span>]<span style="color: #666666">.</span>end() <span style="color: #008000; font-weight: bold">if</span> end_token <span style="color: #666666">&gt;</span> start_token <span style="color: #008000; font-weight: bold">else</span> start_offset
            <span style="color: #008000; font-weight: bold">if</span> end_token <span style="color: #666666">&gt;=</span> <span style="color: #008000">len</span>(matches):
                end_offset <span style="color: #666666">=</span> text_length
            chunk_text <span style="color: #666666">=</span> text[start_offset:end_offset]<span style="color: #666666">.</span>strip()
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> chunk_text:
                <span style="color: #008000; font-weight: bold">if</span> chunks:
                    start_token <span style="color: #666666">+=</span> step
                    chunk_index <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
                    <span style="color: #008000; font-weight: bold">continue</span>
                chunk_text <span style="color: #666666">=</span> normalized_text
            search_text <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_text(chunk_text)
            chunks<span style="color: #666666">.</span>append(
                {
                    <span style="color: #BA2121">&quot;index&quot;</span>: chunk_index,
                    <span style="color: #BA2121">&quot;text&quot;</span>: chunk_text,
                    <span style="color: #BA2121">&quot;token_count&quot;</span>: end_token <span style="color: #666666">-</span> start_token,
                    <span style="color: #BA2121">&quot;start_offset&quot;</span>: start_offset,
                    <span style="color: #BA2121">&quot;end_offset&quot;</span>: end_offset,
                    <span style="color: #BA2121">&quot;search_text&quot;</span>: search_text,
                }
            )
            <span style="color: #008000; font-weight: bold">if</span> end_token <span style="color: #666666">&gt;=</span> <span style="color: #008000">len</span>(matches):
                <span style="color: #008000; font-weight: bold">break</span>
            start_token <span style="color: #666666">+=</span> step
            chunk_index <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> chunks:
            chunk_text <span style="color: #666666">=</span> normalized_text
            chunks<span style="color: #666666">.</span>append(
                {
                    <span style="color: #BA2121">&quot;index&quot;</span>: <span style="color: #666666">0</span>,
                    <span style="color: #BA2121">&quot;text&quot;</span>: chunk_text,
                    <span style="color: #BA2121">&quot;token_count&quot;</span>: <span style="color: #008000">len</span>(matches),
                    <span style="color: #BA2121">&quot;start_offset&quot;</span>: <span style="color: #666666">0</span>,
                    <span style="color: #BA2121">&quot;end_offset&quot;</span>: <span style="color: #008000">len</span>(chunk_text),
                    <span style="color: #BA2121">&quot;search_text&quot;</span>: <span style="color: #008000">self</span><span style="color: #666666">.</span>_normalize_text(chunk_text),
                }
            )
        <span style="color: #008000; font-weight: bold">return</span> chunks
</code></pre>
<h3 id="_build_preview">Method: _build_preview(text: str, *, limit: int=320) -&gt; str</h3>
<p>The function `_build_preview` generates a truncated preview of a given text string, ensuring that the output does not exceed a specified character limit. If the input text is shorter than or equal to the limit, it is returned unchanged. Otherwise, the text is cut off at the last space within the limit, and an ellipsis (&quot;‚Ä¶&quot;) is appended to indicate truncation. If no space is found within the limit, the text is truncated exactly at the limit.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_build_preview</span>(text: <span style="color: #008000">str</span>, <span style="color: #666666">*</span>, limit: <span style="color: #008000">int</span> <span style="color: #666666">=</span> <span style="color: #666666">320</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">str</span>:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(text) <span style="color: #666666">&lt;=</span> limit:
            <span style="color: #008000; font-weight: bold">return</span> text
        cutoff <span style="color: #666666">=</span> text<span style="color: #666666">.</span>rfind(<span style="color: #BA2121">&quot; &quot;</span>, <span style="color: #666666">0</span>, limit)
        <span style="color: #008000; font-weight: bold">if</span> cutoff <span style="color: #666666">==</span> <span style="color: #666666">-1</span>:
            cutoff <span style="color: #666666">=</span> limit
        <span style="color: #008000; font-weight: bold">return</span> text[:cutoff]<span style="color: #666666">.</span>rstrip() <span style="color: #666666">+</span> <span style="color: #BA2121">&quot;‚Ä¶&quot;</span>
</code></pre>
<h3 id="_decode_document_row">Method: _decode_document_row(row: sqlite3.Row | None) -&gt; dict[str, Any] | None</h3>
<p>The function `_decode_document_row` converts a SQLite database row into a Python dictionary, handling the deserialization of JSON-encoded fields. It takes a row from a SQLite query result and transforms it into a dictionary where each key-value pair corresponds to a column in the row. For specific fields (&quot;metadata&quot;, &quot;sections&quot;, &quot;pages&quot;), it parses the stored JSON string into Python objects. It also ensures the &quot;needs_ocr&quot; field is converted to a boolean value. If the input row is `None`, the function returns `None`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_decode_document_row</span>(row: sqlite3<span style="color: #666666">.</span>Row <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        record <span style="color: #666666">=</span> {key: row[key] <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> row<span style="color: #666666">.</span>keys()}
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #BA2121">&quot;metadata&quot;</span>, <span style="color: #BA2121">&quot;sections&quot;</span>, <span style="color: #BA2121">&quot;pages&quot;</span>):
            <span style="color: #008000; font-weight: bold">if</span> record<span style="color: #666666">.</span>get(key):
                record[key] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[key])
        record[<span style="color: #BA2121">&quot;needs_ocr&quot;</span>] <span style="color: #666666">=</span> <span style="color: #008000">bool</span>(record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;needs_ocr&quot;</span>))
        <span style="color: #008000; font-weight: bold">return</span> record
</code></pre>
<h2 id="ChatRepository">Class: ChatRepository</h2>
<p>The `ChatRepository` class provides methods to manage chat sessions, including creating, retrieving, listing, and deleting chats, as well as handling query scopes associated with chats. It also supports operations on citations and reasoning summaries linked to chat sessions, such as adding, retrieving, and listing them. The class uses a database connection and handles JSON serialization for query scope data.</p>
<h3 id="create">Method: create(self, project_id: int, title: str | None=None, *, query_scope: dict[str, Any] | None=None) -&gt; dict[str, Any]</h3>
<p>The `create` method inserts a new chat record into the `chats` table with the specified project ID, title, and query scope. The query scope is serialized to JSON if provided. It returns the created chat record by calling the `get` method with the newly inserted chat ID. The operation is performed within a database transaction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create</span>(
        <span style="color: #008000">self</span>,
        project_id: <span style="color: #008000">int</span>,
        title: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        <span style="color: #666666">*</span>,
        query_scope: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        payload <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(query_scope) <span style="color: #008000; font-weight: bold">if</span> query_scope <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;INSERT INTO chats (project_id, title, query_scope) VALUES (?, ?, ?)&quot;</span>,
                (project_id, title, payload),
            )
            chat_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(chat_id)
</code></pre>
<h3 id="get">Method: get(self, chat_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a chat entry from the database by its ID and returns it as a dictionary, or None if not found. The retrieved data is decoded using the `_decode_chat_row` method.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM chats WHERE id = ?&quot;</span>, (chat_id,)
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_chat_row(row)
</code></pre>
<h3 id="list_for_project">Method: list_for_project(self, project_id: int) -&gt; list[dict[str, Any]]</h3>
<p>Returns a list of decoded chat records associated with a specified project ID, ordered by creation date in ascending order. Each chat record is retrieved from the database using a SELECT query filtered by `project_id`, and then decoded using the `_decode_chat_row` method. Empty or invalid records are excluded from the final result.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_for_project</span>(<span style="color: #008000">self</span>, project_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM chats WHERE project_id = ? ORDER BY created_at ASC&quot;</span>,
            (project_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [record <span style="color: #008000; font-weight: bold">for</span> record <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>_decode_chat_row(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows) <span style="color: #008000; font-weight: bold">if</span> record]
</code></pre>
<h3 id="get_query_scope">Method: get_query_scope(self, chat_id: int) -&gt; dict[str, Any] | None</h3>
<p>The function `get_query_scope` retrieves the query scope associated with a specific chat identified by `chat_id`. It first fetches the chat object using the `get` method of the repository. If the chat does not exist, it returns `None`. If the chat exists, it extracts the `query_scope` field from the chat object. The function validates that the `query_scope` is a dictionary; if not, it returns `None`. The purpose of this function is to provide access to the query scope configuration for a given chat, ensuring type safety by confirming the returned value is a dictionary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_query_scope</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        chat <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(chat_id)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> chat:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        scope <span style="color: #666666">=</span> chat<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;query_scope&quot;</span>)
        <span style="color: #008000; font-weight: bold">return</span> scope <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(scope, <span style="color: #008000">dict</span>) <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
</code></pre>
<h3 id="set_query_scope">Method: set_query_scope(self, chat_id: int, scope: dict[str, Any] | None) -&gt; dict[str, Any] | None</h3>
<p>The function `set_query_scope` updates the query scope for a specified chat session in the database. It accepts a chat ID and a scope dictionary (or None), serializes the scope to JSON, and stores it in the `chats` table under the `query_scope` column. The function uses a database transaction to ensure atomicity of the update operation. After updating, it retrieves and returns the updated chat record by calling the `get` method with the provided chat ID. If the scope is None, it stores a NULL value in the database.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">set_query_scope</span>(
        <span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>, scope: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        payload <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(scope) <span style="color: #008000; font-weight: bold">if</span> scope <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;UPDATE chats SET query_scope = ? WHERE id = ?&quot;</span>,
                (payload, chat_id),
            )
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(chat_id)
</code></pre>
<h3 id="delete">Method: delete(self, chat_id: int) -&gt; None</h3>
<p>The `delete` method removes a chat entry from the database by its ID. It executes a SQL DELETE statement within a transactional context to ensure data consistency. The method takes a single parameter, `chat_id`, which specifies the identifier of the chat to be deleted.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">delete</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(<span style="color: #BA2121">&quot;DELETE FROM chats WHERE id = ?&quot;</span>, (chat_id,))
</code></pre>
<h3 id="add_citation">Method: add_citation(self, chat_id: int, *, document_id: int | None=None, file_version_id: int | None=None, snippet: str | None=None) -&gt; dict[str, Any]</h3>
<p>The function `add_citation` inserts a new citation record into the `citations` table within the database. It accepts parameters for `chat_id`, `document_id`, `file_version_id`, and `snippet`, and returns the inserted citation&#x27;s data by calling `get_citation` with the newly created citation ID. The operation is performed within a database transaction to ensure data consistency.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">add_citation</span>(
        <span style="color: #008000">self</span>,
        chat_id: <span style="color: #008000">int</span>,
        <span style="color: #666666">*</span>,
        document_id: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        file_version_id: <span style="color: #008000">int</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        snippet: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO citations (chat_id, document_id, file_version_id, snippet)</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (chat_id, document_id, file_version_id, snippet),
            )
            citation_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_citation(citation_id)
</code></pre>
<h3 id="get_citation">Method: get_citation(self, citation_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a citation record from the database by its ID and returns it as a dictionary. If no record is found, returns None.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_citation</span>(<span style="color: #008000">self</span>, citation_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM citations WHERE id = ?&quot;</span>,
            (citation_id,),
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
</code></pre>
<h3 id="list_citations">Method: list_citations(self, chat_id: int) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_citations` retrieves all citation records associated with a specified chat ID from the database. It executes a SQL query to select rows from the `citations` table where the `chat_id` matches the provided value, ordering the results by `created_at` in ascending order. Each retrieved row is converted to a dictionary using the helper method `_row_to_dict`, and the resulting list of dictionaries is returned. The function filters out any None values from the query results before processing.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_citations</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM citations WHERE chat_id = ? ORDER BY created_at ASC&quot;</span>,
            (chat_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="add_reasoning_summary">Method: add_reasoning_summary(self, chat_id: int, content: str) -&gt; dict[str, Any]</h3>
<p>The function `add_reasoning_summary` inserts a new reasoning summary into the `reasoning_summaries` table with the provided `chat_id` and `content`. It uses a database transaction to ensure data integrity, retrieves the ID of the newly inserted row, and then fetches and returns the inserted summary using the `get_reasoning_summary` method. The function returns a dictionary representation of the inserted reasoning summary.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">add_reasoning_summary</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>, content: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">&quot;INSERT INTO reasoning_summaries (chat_id, content) VALUES (?, ?)&quot;</span>,
                (chat_id, content),
            )
            summary_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_reasoning_summary(summary_id)
</code></pre>
<h3 id="get_reasoning_summary">Method: get_reasoning_summary(self, summary_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a reasoning summary from the database by its ID and returns it as a dictionary, or None if not found.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_reasoning_summary</span>(<span style="color: #008000">self</span>, summary_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM reasoning_summaries WHERE id = ?&quot;</span>,
            (summary_id,),
        )<span style="color: #666666">.</span>fetchone()
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
</code></pre>
<h3 id="list_reasoning_summaries">Method: list_reasoning_summaries(self, chat_id: int) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_reasoning_summaries` retrieves all reasoning summaries associated with a specified chat ID from the database. It executes a SQL query to select rows from the `reasoning_summaries` table where the `chat_id` matches the provided value, ordering the results by `created_at` in ascending order. Each retrieved row is converted to a dictionary using the `_row_to_dict` helper method, and the function returns a list of these dictionaries, excluding any None values.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_reasoning_summaries</span>(<span style="color: #008000">self</span>, chat_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">&quot;SELECT * FROM reasoning_summaries WHERE chat_id = ? ORDER BY created_at ASC&quot;</span>,
            (chat_id,),
        )<span style="color: #666666">.</span>fetchall()
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row) <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>]
</code></pre>
<h3 id="_decode_chat_row">Method: _decode_chat_row(row: sqlite3.Row | None) -&gt; dict[str, Any] | None</h3>
<p>The function `_decode_chat_row` converts a SQLite database row into a dictionary, handling the deserialization of the `query_scope` field if it exists. It takes a row from a SQLite query result and returns a dictionary with all column values, where the `query_scope` value is parsed from a JSON string into a Python object. If the input row is `None`, the function returns `None`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_decode_chat_row</span>(row: sqlite3<span style="color: #666666">.</span>Row <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> row <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">None</span>
        record <span style="color: #666666">=</span> {key: row[key] <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> row<span style="color: #666666">.</span>keys()}
        <span style="color: #008000; font-weight: bold">if</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;query_scope&quot;</span>):
            record[<span style="color: #BA2121">&quot;query_scope&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;query_scope&quot;</span>])
        <span style="color: #008000; font-weight: bold">return</span> record
</code></pre>
<h2 id="BackgroundTaskLogRepository">Class: BackgroundTaskLogRepository</h2>
<p>The `BackgroundTaskLogRepository` class provides methods to store and retrieve metadata for background task executions, including creating new task logs, updating their status, and querying incomplete or completed tasks. It supports storing additional structured data as JSON and handles database transactions for data integrity. The class offers functionality to list tasks based on their status and retrieve the latest or all completed tasks for a given name.</p>
<h3 id="create">Method: create(self, task_name: str, *, status: str, message: str | None=None, extra_data: dict[str, Any] | None=None) -&gt; dict[str, Any]</h3>
<p>The `create` method inserts a new record into the `background_task_logs` table with the specified task name, status, optional message, and optional extra data. The extra data is serialized to JSON before being stored. The method returns the created task record by calling the `get` method with the newly inserted task&#x27;s ID. The operation is performed within a database transaction.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create</span>(
        <span style="color: #008000">self</span>,
        task_name: <span style="color: #008000">str</span>,
        <span style="color: #666666">*</span>,
        status: <span style="color: #008000">str</span>,
        message: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        extra_data: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]:
        payload <span style="color: #666666">=</span> json<span style="color: #666666">.</span>dumps(extra_data) <span style="color: #008000; font-weight: bold">if</span> extra_data <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">None</span>
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            cursor <span style="color: #666666">=</span> connection<span style="color: #666666">.</span>execute(
<span style="color: #bbbbbb">                </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">                INSERT INTO background_task_logs (task_name, status, message, extra_data)</span>
<span style="color: #BA2121; font-style: italic">                VALUES (?, ?, ?, ?)</span>
<span style="color: #BA2121; font-style: italic">                &quot;&quot;&quot;</span>,
                (task_name, status, message, payload),
            )
            task_id <span style="color: #666666">=</span> cursor<span style="color: #666666">.</span>lastrowid
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(task_id)
</code></pre>
<h3 id="get">Method: get(self, task_id: int) -&gt; dict[str, Any] | None</h3>
<p>Retrieves a specific background task log record from the database by its ID. Returns the record as a dictionary, with the `extra_data` field parsed from JSON if present. If no record is found, returns `None`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get</span>(<span style="color: #008000">self</span>, task_id: <span style="color: #008000">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;SELECT * FROM </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>TABLE<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> WHERE id = ?&quot;</span>,
            (task_id,),
        )<span style="color: #666666">.</span>fetchone()
        record <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
        <span style="color: #008000; font-weight: bold">if</span> record <span style="color: #AA22FF; font-weight: bold">and</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;extra_data&quot;</span>):
            record[<span style="color: #BA2121">&quot;extra_data&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;extra_data&quot;</span>])
        <span style="color: #008000; font-weight: bold">return</span> record
</code></pre>
<h3 id="update">Method: update(self, task_id: int, *, status: str | None=None, message: str | None=None, extra_data: dict[str, Any] | None=None, completed_at: str | None=None) -&gt; dict[str, Any] | None</h3>
<p>The `update` method in the `BackgroundTaskLogRepository` class modifies specific fields of a background task record identified by `task_id`. It accepts optional parameters for `status`, `message`, `extra_data`, and `completed_at`, updating only those fields that are provided. The method constructs an SQL `UPDATE` statement dynamically based on the provided fields, and executes it within a transaction. If no fields are specified for update, the method retrieves and returns the current task record. The `extra_data` parameter is serialized to JSON before being stored. The method returns the updated task record as a dictionary, or `None` if the task is not found.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">update</span>(
        <span style="color: #008000">self</span>,
        task_id: <span style="color: #008000">int</span>,
        <span style="color: #666666">*</span>,
        status: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        message: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        extra_data: <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
        completed_at: <span style="color: #008000">str</span> <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span> <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>,
    ) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        updates: <span style="color: #008000">list</span>[<span style="color: #008000">str</span>] <span style="color: #666666">=</span> []
        values: <span style="color: #008000">list</span>[Any] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">if</span> status <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            updates<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;status = ?&quot;</span>)
            values<span style="color: #666666">.</span>append(status)
        <span style="color: #008000; font-weight: bold">if</span> message <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            updates<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;message = ?&quot;</span>)
            values<span style="color: #666666">.</span>append(message)
        <span style="color: #008000; font-weight: bold">if</span> extra_data <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            updates<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;extra_data = ?&quot;</span>)
            values<span style="color: #666666">.</span>append(json<span style="color: #666666">.</span>dumps(extra_data))
        <span style="color: #008000; font-weight: bold">if</span> completed_at <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
            updates<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;completed_at = ?&quot;</span>)
            values<span style="color: #666666">.</span>append(completed_at)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> updates:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(task_id)
        values<span style="color: #666666">.</span>append(task_id)
        <span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>transaction() <span style="color: #008000; font-weight: bold">as</span> connection:
            connection<span style="color: #666666">.</span>execute(
                <span style="color: #BA2121">f&quot;UPDATE </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>TABLE<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> SET </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join(updates)<span style="color: #A45A77; font-weight: bold">}</span><span style="color: #BA2121"> WHERE id = ?&quot;</span>,
                values,
            )
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get(task_id)
</code></pre>
<h3 id="list_incomplete">Method: list_incomplete(self) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_incomplete` retrieves all records from the repository&#x27;s database table where the status is either &#x27;queued&#x27;, &#x27;running&#x27;, or &#x27;paused&#x27;. It orders the results by creation time in ascending order. Each retrieved row is converted into a dictionary, and if the record contains extra data, it is parsed from JSON format. The function returns a list of these processed records.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_incomplete</span>(<span style="color: #008000">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;&quot;&quot;</span>
<span style="color: #BA2121">            SELECT * FROM </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>TABLE<span style="color: #A45A77; font-weight: bold">}</span>
<span style="color: #BA2121">            WHERE status IN (&#39;queued&#39;, &#39;running&#39;, &#39;paused&#39;)</span>
<span style="color: #BA2121">            ORDER BY created_at ASC</span>
<span style="color: #BA2121">            &quot;&quot;&quot;</span>
        )<span style="color: #666666">.</span>fetchall()
        records: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows:
            record <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
            <span style="color: #008000; font-weight: bold">if</span> record <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000; font-weight: bold">None</span>:
                <span style="color: #008000; font-weight: bold">continue</span>
            <span style="color: #008000; font-weight: bold">if</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;extra_data&quot;</span>):
                record[<span style="color: #BA2121">&quot;extra_data&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;extra_data&quot;</span>])
            records<span style="color: #666666">.</span>append(record)
        <span style="color: #008000; font-weight: bold">return</span> records
</code></pre>
<h3 id="find_latest_completed">Method: find_latest_completed(self, task_name: str) -&gt; dict[str, Any] | None</h3>
<p>The function `find_latest_completed` retrieves the most recent completed record for a specified task name from a database table. It queries the table where the task name matches and the status is &#x27;completed&#x27;, ordering results by completion time and creation time in descending order to find the latest entry. The returned record includes parsed JSON data for the `extra_data` field if present. If no matching record is found, it returns `None`.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_latest_completed</span>(<span style="color: #008000">self</span>, task_name: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any] <span style="color: #666666">|</span> <span style="color: #008000; font-weight: bold">None</span>:
        row <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;&quot;&quot;</span>
<span style="color: #BA2121">            SELECT * FROM </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>TABLE<span style="color: #A45A77; font-weight: bold">}</span>
<span style="color: #BA2121">            WHERE task_name = ? AND status = &#39;completed&#39;</span>
<span style="color: #BA2121">            ORDER BY completed_at DESC NULLS LAST, created_at DESC</span>
<span style="color: #BA2121">            LIMIT 1</span>
<span style="color: #BA2121">            &quot;&quot;&quot;</span>,
            (task_name,),
        )<span style="color: #666666">.</span>fetchone()
        record <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
        <span style="color: #008000; font-weight: bold">if</span> record <span style="color: #AA22FF; font-weight: bold">and</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;extra_data&quot;</span>):
            record[<span style="color: #BA2121">&quot;extra_data&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;extra_data&quot;</span>])
        <span style="color: #008000; font-weight: bold">return</span> record
</code></pre>
<h3 id="list_completed">Method: list_completed(self, task_name: str) -&gt; list[dict[str, Any]]</h3>
<p>The function `list_completed` retrieves all completed background tasks from the database that match a specified task name. It queries the repository&#x27;s table, filtering for records where the `task_name` matches the input and the `status` is &#x27;completed&#x27;. The results are ordered by `completed_at` in descending order, with null values last, followed by `created_at` in descending order. Each retrieved row is converted into a dictionary using `_row_to_dict`, and if the record contains `extra_data`, it is parsed from JSON format. The function returns a list of these processed records.</p>
<pre><code><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">list_completed</span>(<span style="color: #008000">self</span>, task_name: <span style="color: #008000">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]]:
        rows <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>db<span style="color: #666666">.</span>connect()<span style="color: #666666">.</span>execute(
            <span style="color: #BA2121">f&quot;&quot;&quot;</span>
<span style="color: #BA2121">            SELECT * FROM </span><span style="color: #A45A77; font-weight: bold">{</span><span style="color: #008000">self</span><span style="color: #666666">.</span>TABLE<span style="color: #A45A77; font-weight: bold">}</span>
<span style="color: #BA2121">            WHERE task_name = ? AND status = &#39;completed&#39;</span>
<span style="color: #BA2121">            ORDER BY completed_at DESC NULLS LAST, created_at DESC</span>
<span style="color: #BA2121">            &quot;&quot;&quot;</span>,
            (task_name,),
        )<span style="color: #666666">.</span>fetchall()
        records: <span style="color: #008000">list</span>[<span style="color: #008000">dict</span>[<span style="color: #008000">str</span>, Any]] <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> rows:
            record <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>_row_to_dict(row)
            <span style="color: #008000; font-weight: bold">if</span> record <span style="color: #AA22FF; font-weight: bold">and</span> record<span style="color: #666666">.</span>get(<span style="color: #BA2121">&quot;extra_data&quot;</span>):
                record[<span style="color: #BA2121">&quot;extra_data&quot;</span>] <span style="color: #666666">=</span> json<span style="color: #666666">.</span>loads(record[<span style="color: #BA2121">&quot;extra_data&quot;</span>])
            <span style="color: #008000; font-weight: bold">if</span> record:
                records<span style="color: #666666">.</span>append(record)
        <span style="color: #008000; font-weight: bold">return</span> records
</code></pre>
    </div>
    <script src="static/toggle.js"></script>
</body>
</html>
